1. 添加新POST字段已经相关的test case：update_sub_Field/enent_field
2. 添加对应的enum
3. 添加对应的error
1. db structure
	user
	user sugar
	
	
2. api


1. 如果字段的值是数组[ObjectId]/[enum]，需要检查是不是有重复值（防止重复元素，例如，同一条评论出现多次），在一个新的函数中（而不是validateValue）检测重复
2. 把除了admin_user之外的所有model中，field类型为enum的，全部改成String===>done
3. 新增数据类型bollean，需要在validateHelper-valueTypeCheck中添加对其的检查(validateValue调用此函数进行type的检测)

1. 添加新表 recommend（记录用户的推荐（以及用户收到的推荐））/admin_penalize（记录管理员直接对普通用户做出的处罚，包括禁止写文档/系列/评论）/topic（普通用户新建的系列）/user_punished_history(记录用户的处罚历史已经处罚状态)=========>done

1. 添加新表，给用户存储收藏的文档==========> done: collection
1.1 只有一级目录
1.2 字段：creatorId/name（收藏夹名称）/articlesId（收藏夹中的文档）


1. install gm========>done


1. dataConvert es7化===>done
2. internalInputRule中，如果是enum，直接使用model/mongo/enumValue，而不是使用Object.values方法（节省资源）====>done

1. controller中，添加validatePartFormat，对各part的format进行检查，防止recordInfo中出现不存在field的错误===>done
2. 添加API，对单独字段进行unique进行检查（以便client及时反馈结果给用户）========>done

1. 设定新enum，inputFieldCheckType，BASE_INPUTRULE,BASE_INPUT=======>done(暂时只用在_validateRecorderValue，validateSingleFieldValue的代码做了简化，不需要用此enum)


1. user->update->password需要hash后和原始记录比较======》done


1. API中，一旦输入参数检查通过，立刻调用函数转换成{field:value}的形式=====>done
2. 使用公司邮件发邮件（且为历史账号）=======>fail(不知SMTP配置)